[{"title":"PHP Overloading","date":"2017-11-23T15:00:00.000Z","path":"2017/11/24/php-overloading/","text":"PHP OverloadingPHP Overloading은 자바에서의 Overloading과 다릅니다. 자바에서의 Overloading은 다음 예제와 같이 method 이름은 같지만 parameter type 또는 갯수가 다른 여러개의 method가 존재하여 용도별로 사용하는 것을 말합니다. 1234567891011public int add(int a, int b) &#123; return a + b;&#125; public float add(float a, float b) &#123; return a + b;&#125;public int add(int a, int b, int c) &#123; return a + b + c;&#125; 하지만 PHP Overloading은 동적으로 method나 property를 생성하는 것을 말합니다. 즉 이 말은 실행 시점에서 method나 property가 없는데 동적으로 생성하여 클래스를 임의로 확장할 수 있다는 말입니다. 이렇게 동적으로 생성된 멤버는 magic method를 통해 다양한 형태로 처리할 수 있습니다. 이때 magic method란 PHP에서 특수한 기능을 위해 미리 정의한 메소드로서 __ (두개의 언더스코어)로 시작합니다. overloading된 메소드는 반드시 public으로 정의되어야 합니다. Property OverloadingProperty overloading은 __set, __get, __isset, __unset을 통해 이루어 집니다. 1234567891011121314151617181920212223242526&lt;?phpclass DynamicPropertyTest&#123; private $data = array(); public function __set($key, $value) &#123; $this-&gt;data[$key] = $value; &#125; public function __get($key) &#123; if(array_key_exists($key, $this-&gt;data)) &#123; return $this-&gt;data[$key]; &#125; else &#123; throw new UnexpectedValueException($key . '은 없는 값입니다.'); &#125; &#125;&#125;$prop = new DynamicPropertyTest();$prop-&gt;title = \"DynamicProperty!\";echo $prop-&gt;title;echo $prop-&gt;content; __set() method는 property 값을 설정할 때 호출되며 __get() method는 property 값을 읽을 때 호출됩니다.위 코드를 실행하면 title이라는 property를 동적으로 생성되어 DynamicProperty! 라는 제목이 출력 될 것입니다. 하지만 content라는 프로퍼티는 생성을 하지 않았으므로 UnexpectedValueException이 발생할 것입니다. 다음은 실행 결과입니다. 123456789101112php DynamicPropertyTest.phpDynamicProperty!PHP Fatal error: Uncaught UnexpectedValueException: content은 없는 값입니다. in /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php:17Stack trace:#0 /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php(26): DynamicPropertyTest-&gt;__get(&apos;content&apos;)#1 &#123;main&#125; thrown in /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php on line 17Fatal error: Uncaught UnexpectedValueException: content은 없는 값입니다. in /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php:17Stack trace:#0 /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php(26): DynamicPropertyTest-&gt;__get(&apos;content&apos;)#1 &#123;main&#125; thrown in /Users/SeungUk/PhpstormProjects/ModernPHP/DynamicPropertyTest.php on line 17 Property overloading을 통해 런타임에 property가 생성되고 사용할 수 있다는 것을 확인할 수 있습니다. Method OverloadingMethod Overloading 같은 경우는 일반 method일 경우에는 __call, static method일 경우에는 __callStatic을 구현하면 됩니다. 123456789101112131415161718192021222324&lt;?phpclass DynamicMethodTest&#123; public function __call($name, $arg) &#123; echo \"일반 method : $name' \"; echo \"argument : \" . implode(', ', $arg). \"\\n\"; &#125; public static function __callStatic($name, $arg) &#123; echo \"static method : '$name' \"; echo \"argument : \" . implode(', ', $arg). \"\\n\"; &#125;&#125;// class 내 method로 호출$obj = new DynamicMethodTest();$obj-&gt;whereName('name', 'seunguk');// static method로 호출DynamicMethodTest::whereName('name', 'seunguk'); 위의 코드를 보시면 DynamicMethodTesst 클래스에 없는 whereName method를 호출하였지만 PHP 인터프리터가 자동으로 생성해준것을 확인할 수 있습니다. 123php DynamicMethodTest.php일반 method : whereName&apos; argument : name, seungukstatic method : &apos;whereName&apos; argument : name, seunguk Dynamic Property and Dynamic Method는 런타임에 임의의 method와 property를 소스 수정없이 만들 수 있으므로 유연함과 확장성을 제공합니다. [참고 자료] https://www.lesstif.com/pages/viewpage.action?pageId=26083489 http://tcpschool.com/php/php_oop_overloading","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"}]},{"title":"trait","date":"2017-11-15T15:00:00.000Z","path":"2017/11/16/trait/","text":"trait(트레이트)trait(트레이트)는 PHP 5.4에 도입되었는데 클래스처럼 행동하지만 보기에는 인터페이스 같아 많이 혼란스러워하는 사람이 많습니다. 우선 트레이트 둘 다면서 둘 다 아닙니다. 트레이트는 부분적으로 구현된 클래스(상수, 프로퍼티, 메서드)며 기존 PHP 클래스에 여러개 추가할 수 있습니다.트레이트는 두 가지 기능을 수행하는데 하나 는 인터페이스처럼 클래스가 할 수 있는 것을 나타내고 두번째 는 클래스처럼 모듈화된 구현을 제공합니다. (트레이트는 루비의 믹스인과 유사합니다.) 왜 트레이트를 사용할까?PHP도 다른 언어에서 사용하는 것처럼 상속 모델을 사용합니다. 기본적인 구현을 제공하는 일반화된 하나의 클래스와 이 클래스를 확장해 나가면서 바로 윗 부모의 구현을 상속받아 좀 더 특화된 클래스를 생성합니다(이를 상속계층 이라고 합니다). 이러한 상속 모델은 대부분 잘 작동합니다. 하지만 연관이 없는 두 PHP 클래스가 유사한 행동을 해야할 겨우 어떻게 해야할까요? 예를 들어 RetailStore(소매점) 과 Car(자동차) 클래스가 있다고 합시다. 이 둘의 클래스는 전혀 연관이 없는 클래스입니다. 그러므로 이 두 클래스는 상속 계층상 공통의 부모를 공유하지 않습니다. 하지만 두 클래스 모두 지도 위에 위도와 경도(위치정보)를 표시해야 된다고 합시다. 이때 바로 트레이트를 사용합니다. 트레이트를 이용하면 모듈화된 구현을 서로 관련 없는 클래스들에 주입할 수 있습니다. 트레이트의 사용으로 코드 재사용성을 높일 수 있는 장점도 있습니다. 다음은 위의 문제점이 생겼다고 가정하고 트레이트를 사용을 했을 경우와 그렇지 않은 경우를 살펴 봅시다. RetailStore 와 Car 클래스가 확장할 공통의 부모 클래스 Geocodable을 만든다. (트레이트 사용 x)결론부터 말씀드리자면 이 방법은 결코 좋은 해결책이 아닙니다. 왜냐하면 서로 관련이 없는 두 클래스가 어느 쪽의 상속 계층에도 속하지 않는 공통의 조상을 공유하였기 때문입니다. Geocodable 인터페이스를 만들어 위치정보 기능을 구현할 메서드를 정의. (트레이트 사용 x)RetailStore 와 Car 클래스 모두 Geocodable을 구현 할 수 있습니다. 1번 방법과 달리 와 Car 이 두 클래스 모두 자연스러운 상속 계층을 유지할 수 있어 좋은 해결책이 될 수 있습니다. 하지만 두 클래스에 같은 지리정보 기능이 중복되는 단점이 있습니다. 위치정보 메서드를 구현한 Geocodable 트레이트 생성 (트레이트 사용 o)RetailStore 와 Car 두 클래스 모두에 Geocodable 트레이트를 넣을 수 있어 클래스의 자연적인 상속 계층이 망가지지 않는 장점이 있어 최고의 해결책이라고 할 수 있습니다. 위 문제점은 상속과 인터페이스로 최고의 해결책이 될 수 없으며 트레이트를 이용하여 해결할 수 있습니다. 트레이트 생성Geocodable 트레이트는 다음과 같이 구현할 수 있습니다. 12345678910111213141516171819202122232425262728293031&lt;?phptrait Geocodable &#123; /* 여기에 트레이트를 구현하시면 됩니다. **/ protected $address; protected $geocoder; protected $geocoderResult; public function setGeocoder($geocoder) &#123; /* .... */ &#125; public function setAddress($address) &#123; /* .... */ &#125; public function getLatitude() &#123; /* .... */ &#125; public function getLongtitude() &#123; /* .... */ &#125; protected function geocodeAddress() &#123; /* .... */ &#125; // .....&#125; 다음과 같이 Geocodable 트레이트는 위치정보 기능을 구현하기 위해 필요한 속성과 메서드를 정의하면 됩니다. 트레이트 사용PHP 트레이트는 use 키워드로 간단하게 사용할 수 있습니다. 다음과 같이 PHP 클래스 정의 안에 코드를 추가하시면 됩니다. 12345678&lt;?phpclass RetailStore&#123; use Geocodable; /* 여기에 클래스를 구현하시면 됩니다. */&#125; namespace도 트레이트와 마찬가지로 use 키워드를 사용하여 import하지만 import가 되는 위치가 다릅니다. namespace, class, interface는 클래스 정의 밖에 import하는 반면에 트레이트는 클래스 정의 안에서 import합니다. 이제 각 RetailStore 인스턴스는 Geocodable 트레이트가 제공하는 속성과 메서드들을 다음과 같이 사용 할 수 있습니다. 123456789&lt;?php$store = new RetailStore();$store-&gt;setAddress();$store-&gt;setGeocoder();$latitude = $store-&gt;getLatitude();$longtitude = $store-&gt;getLongtitude();// ... PHP 인터프린터는 컴파일 시에 트레이트를 복사해서 클래스 정의 안에 붙여넣습니다. 그리고 이 과정에서 발생하는 비호환성을 방지하지 않습니다. 트레이트가 트레이트 내부에 정의되어 있지 않은 클래스 속성이나 메서드를 사용한다면 트레이트를 사용하는 클래스 안에 그 속성이나 메서드가 반드시 존재해야합니다.","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"}]},{"title":"git flow tutorial","date":"2017-11-14T15:00:00.000Z","path":"2017/11/15/git-flow/","text":"gitflow란?Vincent Driessen’s의 branching model을 적용하여 고수준으로 저장소를 관리하기 위한 Git 확장 콜렉션이라고 할 수 있습니다.Vincent의 branching model은 “feature - develop - release - hotfixes - master” 단계로 branch를 나눠서 코드를 관리하는 전략입니다. 이렇게 많은 프로세스를 나눠서 작업을 하기에 여간 귀찮은 일이 아니다. 그래서 사용자가 쉽게 접근하여 사용할 수 있도록 확장 명령어 셋을 제공하는 것이 gitflow입니다. gitflow 사용하기우선 gitflow을 사용하려면 다음과 같이 $git flow init 명령어를 사용합니다. 그림 1. git flow init 그러면 다음 그림1 과 같이 프로세스 별로 사용할 branch 명을 입력하라는 메시지가 뜹니다. 기본값으로 사용하고 싶으면 그냥 Enter치시면 됩니다. 그러면 자동으로 develop branch가 생깁니다. 기본적으로 develop에서 개발하고, master로 release하는 방식입니다. gitflow는 기본적으로 master, develop를 제공하며 gitflow에서 제공하는 branch는 총 6종류 입니다. master : 최종 릴리즈한 안정화 버전 develop : 다음 릴리즈를 위해 개발중인 최신 버전 feature : 특정 기능 개발을 위한 branch release : 릴리즈 점검을 위한 branch hotfix : 긴급 버그 픽스를 위한 branch support : 버전 호환성 문제 처리를 위한 branch 특정한 기능을 개발하기 위해서는 feature branch를 이용합니다.$git flow feature start [이름] 이렇게 하면 새로운 기능을 개발하기 위한 branch가 feature/이름이름으로 만들어지면 해당 branch로 자동으로 checkout 됩니다. 그림 2. git flow feature start [이름] 간단하게 hello.txt를 생성하고 hello1 이라는 코드를 작성을 했다고 가정을 해봅시다. 코드 작성 후 변경 사항을 stage에 commit을 합니다. 그림 3,4. 코드 작성 및 git commit 기능 개발이 완료되면 다음 명령어로 git flow에 알려줍니다.$git flow feature finish [이름]이 명령어는 다음과 같은 순서로 동작합니다. git flow는 develop branch로 checkout 한다. feature branch의 변경 내용을 자동으로 develop branch에 merge한다. 작업이 끝난 feature branch를 삭제한다. 그림 5. git flow feature finish [이름] 다음과 같이 변경된 내용을 확인 할 수 있습니다. 이번에는 release를 위해 release branch를 생성을 합니다.$git flow release start [이름] 그림 6. git flow release start [이름] release start를 하면 develop branch의 내용을 base로 release/[이름]의 이름을 갖는 새로운 branch를 하나 만들어서 checkout 하게 됩니다. release branch는 보통 릴리즈 점검을 위해 간단한 버그를 수정하는 등의 작업을 목적으로 사용하며 점검이 끝났으면 다음과 같이 finish 명령어를 사용하시면 됩니다.$git flow release finish [이름]이 명령어는 다음과 같은 순서로 동작합니다. release 브랜치의 코드를 master branch에 merge release의 이름으로 태그 등록 릴리즈를 develop branch로 재병합(back-merge) release branch를 삭제 그림 7,8,9. git flow release finish [이름] 마지막으로 모든 release 작업이 끝났으면 pull 명령으로 원격 저장소에 코드를 저장할 수 있습니다. $git lg 명령으로 그 동안 작업 했던 것들을 볼 수 있습니다. 그림 10. git lg [참고 자료] http://huns.me/development/1131","tags":[{"name":"git","slug":"git","permalink":"https://seunguklee.github.io/tags/git/"}]},{"title":"Laravel View&Blade","date":"2017-11-05T15:00:00.000Z","path":"2017/11/06/laravel-view/","text":"라라벨에서 뷰를 반환하는 방법과 뷰에 데이터를 바인딩하는 방법, 블레이드에 대해 알아보도록 하겠습니다. view() 함수에서 다른 뷰를 반환하려면 어떻게 하면 좋을까요?123Route::get('/', function() &#123; return view('errors.503');&#125;); 위 코드는 resources/views 디렉토리안에 errors/503.blade.php 파일을 반환하는 코드입니다.여기서 몇가지 규칙이 있습니다. 하위 디렉토리에 있는 뷰 파일은 (.)으로 참조할 수 있다. 뷰 파일 이름은 파일이름.blade.php 와 같은 모양이다. .blade.php 없이 파일이름만 인자로 넘긴다. 여기서 View::make() 파사드를 사용하여 view() 함수 대신 사용할 수 있습니다. 파사드는 라라벨4에서 사용하던 문법이고 라라벨5로 넘어오면서 대부분이 함수로 대체되었습니다. 여전히 유효한 문법이므로 사용해도 무방합니다. 데이터 바인딩동적 페이지는 HTML에 적잘한 데이터를 결합하여 만들 수 있습니다.라라벨의 여러가지 데이터 바인딩에 알아봅시다. view() 함수 뒤에 with() 메서드를 체인하여 데이터를 바인딩할 수 있습니다.123Route::get('/', function() &#123; return view('welcom')-&gt;with('name', 'mr.lee');&#125;); 다음과 같이 배열을 이용하여 여러 개의 데이터를 넘길 수 있습니다.123456Route::get('/', function() &#123; return view('welcom')-&gt;with([ 'name' =&gt; 'mr.lee', 'content' =&gt; 'hello', ]);&#125;); with() 메서드를 체인하지 않고 view() 함수의 두번째 인자로 넘기는 방법도 있습니다.123456Route::get('/', function() &#123; return view('welcom', [ 'name' =&gt; 'mr.lee', 'content' =&gt; 'hello', ]);&#125;); [참고 자료] https://appkr.github.io/l5book-snippets/draft/1004-view-data-binding.html","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"}]},{"title":"Laravel Routing","date":"2017-11-05T15:00:00.000Z","path":"2017/11/06/laravel-routing/","text":"URL라우팅에 대해 자세히 알아보기전에 우선 URL에 대해서 알아보겠습니다. 우리는 어떤 웹 페이지에 접속하기 위해 웹 브라우저에 URL을 입력합니다. 예를 들어 foo.com/posts 또는 foo.com/posts.php 처럼 확장자를 가진 것도 있습니다. URL을 구성하는 요소는 다음과 같습니다. http://www.example.com:80/articles?page=2&amp;filter=no_comment#comment-21 http : URL 스킴(URL scheme) 프로토콜 이름 www.example.com www는 호스트 이름이며 example.com은 도메인 이름이다. 80 : 포트 번호 웹 서버의 기본 포트는 80이다. 80번 포트로 요청할 경우 이를 생략 할 수도 있다. articles : 경로(Path) 경로는 www.example.com 이름을 가진 웹 서버 루트 아래에 존재하는 리소스 주소다. 정적 파일일 수도 있고, 동적 파일일 수도 있다. page=2&amp;filter=no_comment : 쿼리 스트링 함수의 인자라고 생각하자. 웹 애플리케이션에게 요청의 세부 사항을 말해야 할 때 필요하다. comment-21 : URL 조각 (URL fragment) 웹 서버에서 받은 응답을 웹 브라우저가 렌더링하면서 URL 조각에 의해 해당하는 화면 위치로 이동된다. Routing 이란?Routing은 HTTP 요청의 메서드와 URL을 보고, 적절한 처리 로직으로 연결시키는 행위를 말합니다.모든 클라이언트 HTTP 요청을 한 곳으로 모으고, 그 시작점에서 적합한 처리 로직에게 할당함으로써 URL과 컨트롤러 로직을 분리 해줍니다. 라라벨 프로젝트를 생성하고 routes/web.php 파일을 열어봅시다.(라라벨 5.3 기준) 123Route::get('/', function() &#123; return view('welcome');&#125;); 이 코드를 살펴보면 Route::get()은 get메서드에 대한 요청을 받는다는 의미입니다.get메서드로 / 요청이 오면 두번째 인자인 클로저 function () { .... } 부분이 동작을 하게 됩니다. return view(&#39;welcome&#39;)에서 인자 ‘welcome’은 resources/views/welcome.blade.php 파일을 말합니다. 보통 HTML 뷰나 문자열을 반환하는 것은 컨트롤러가 하는 일입니다. 컨트롤러의 일을 클로저가 대신하는 것을 볼 수 있습니다. URL 파라미터URL로 넘어 온 파라미터를 참조하려면 {파라미터 이름}와 같이 중괄호를 이용하면 됩니다.만약 URL 파라미터를 받을 수도 있고 안받을 수도 있으면 ? 를 붙이면 됩니다. 123Route::get('/&#123;foo&#125;', function($foo = 'bar') &#123; return $foo;&#125;); 위 코드는 만약 URL 파라미터가 없으면 $foo 는 “bar” 문쟈열을 기본값으로 사용하겠다는 의미입니다. URL 파라미터의 모양에 따라 다른 로직을 실행하거나 필터링을 해야한다면 정규 표현식 을 이용할 수 있습니다.1234Route::pattern('foo', '[0-9a-zA-Z]&#123;3&#125;')Route::get('/&#123;foo&#125;', function($foo = 'bar') &#123; return $foo;&#125;)-&gt;where('foo', '[0-9a-zA-Z]&#123;3&#125;'); 위 코드는 Route::pattern() 과 정규 표현식을 이용하여 foo 파라미터를 숫자, 영어 대/소문자로 구성된 세 자리 글자로 한정하겠다는 예입니다. where()을 체인하여 사용 할 수도 있습니다. Routing Name라우팅에 이름을 부여할 수 있는데 컨트롤러 로직에서 다른 라우트로 리다이렉셔하거나, 뷰에서 다른 라우트로 이동하는 링크를 만들 때 유용합니다. 만약 URL 경로를 갑자기 바꾸어야 한다고 하면 코드를 뒤져서 전부 수정해야 하지만 이름을 지은 URL 경로이면 이러한 수고를 덜 수 있습니다. 사용법은 as =&gt; &#39;라우트 이름&#39;을 정의하면 됩니다. 코드를 봅시다. 123456789Route::get('/', [ 'as' =&gt; 'home', function () &#123; return \"hello\"; &#125;]);Route::get('/home', function() &#123; return redirect(route('home'));&#125;); redirect() 함수는 리다렉션 HTTP 응답을 반환합니다. /에 대한 요청을 받는 라우트를 home 이라고 이름을 정해주었기 때문에 route(&#39;home&#39;)은 http://호스트:포트 문자열을 반환하게 됩니다. Routing Override만약 같은 URL을 두 번 정의하게 되면 아래쪽에 정의한 라우트가 먼저 정의한 라우트를 오버라이드하기 때문에 라우트를 정의할 때 순서에 주의하는게 좋습니다. [참고 자료] https://appkr.github.io/l5book-snippets/draft/1003-routing.html","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"}]},{"title":"Laravel Project Structure","date":"2017-11-04T15:00:00.000Z","path":"2017/11/05/laravel-project-structure/","text":"Laravel 프로젝트를 만들면 다음과 같은 디렉토리가 구성됩니다. (Laravel 5.3 기준) . &#x251C;&#x2500;&#x2500; .env # &#xAE00;&#xB85C;&#xBC8C; &#xC124;&#xC815; &#xC911; &#xBBFC;&#xAC10;&#xD55C; &#xAC12;, &#x2502; # &#xC11C;&#xBE44;&#xC2A4; &#xC2E4;&#xD589; &#xD658;&#xACBD;(&#xAC1C;&#xBC1C;/&#xC6B4;&#xC601;)&#xC5D0; &#xB530;&#xB77C; &#xB2EC;&#xB77C;&#xC838;&#xC57C; &#xD558;&#xB294; &#xAC12;&#xC744; &#xC368; &#xB193;&#xB294; &#xACF3; &#x251C;&#x2500;&#x2500; app &#x2502; &#x251C;&#x2500;&#x2500; Console &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; Commands # &#xC6B0;&#xB9AC;&#xAC00; &#xB9CC;&#xB4E0; &#xCF58;&#xC194; &#xBA85;&#xB839;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x2514;&#x2500;&#x2500; Kernel.php # &#xCF58;&#xC194; &#xBA85;&#xB839;, &#xD06C;&#xB860; &#xC791;&#xC5C5;&#xC744; &#xB4F1;&#xB85D;&#xD558;&#xB294; &#xB808;&#xC9C0;&#xC2A4;&#xD2B8;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; Events # &#xC6B0;&#xB9AC;&#xAC00; &#xB9CC;&#xB4E0; &#xC774;&#xBCA4;&#xD2B8; &#xD074;&#xB798;&#xC2A4;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; Exceptions # &#xC6B0;&#xB9AC;&#xAC00; &#xB9CC;&#xB4E0; &#xC608;&#xC678;(Exception) &#xD074;&#xB798;&#xC2A4;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x2514;&#x2500;&#x2500; Handler.php # &#xC804;&#xC5ED; &#xC608;&#xC678; &#xCC98;&#xB9AC; &#xADDC;&#xCE59;&#xC744; &#xC815;&#xC758;&#xD55C; &#xD074;&#xB798;&#xC2A4; &#x2502; &#x251C;&#x2500;&#x2500; Http # HTTP &#xC694;&#xCCAD;&#xC744; &#xCC98;&#xB9AC;&#xD558;&#xB294; &#xD074;&#xB798;&#xC2A4;&#xB4E4;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; Controllers # HTTP &#xC694;&#xCCAD;&#xC744; &#xCC98;&#xB9AC;&#xD558;&#xB294; &#xCEE8;&#xD2B8;&#xB864;&#xB7EC;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; Kernel.php # HTTP &#xC694;&#xCCAD; &#xCC98;&#xB9AC;&#xB97C; &#xC704;&#xD574; &#xAE30;&#xBCF8;&#xC774; &#xB418;&#xB294; &#xCEE4;&#xB110; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; Middleware # &#xBBF8;&#xB4E4;&#xC6E8;&#xC5B4;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; Requests # HTTP &#xD3FC; &#xB9AC;&#xD018;&#xC2A4;&#xD2B8;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x2514;&#x2500;&#x2500; routes.php # &#xC694;&#xCCAD; URL&#xACFC; &#xCC98;&#xB9AC; &#xB85C;&#xC9C1;(&#xCEE8;&#xD2B8;&#xB864;&#xB7EC;)&#xC744; &#xC5F0;&#xACB0;&#xD558;&#xB294; &#xB9E4;&#xD551; &#xD14C;&#xC774;&#xBE14; &#x2502; &#x251C;&#x2500;&#x2500; Jobs # &#xD050; &#xC791;&#xC5C5; &#xCC98;&#xB9AC;&#xAE30;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; Listeners # &#xC774;&#xBCA4;&#xD2B8; &#xB9AC;&#xC2A4;&#xB108;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; Policies # &#xC811;&#xADFC; &#xAD8C;&#xD55C; &#xC81C;&#xC5B4;&#xB97C; &#xC704;&#xD55C; &#xC815;&#xCC45;&#xB4E4;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; Providers # &#xC11C;&#xBE44;&#xC2A4; &#xD504;&#xB85C;&#xBC14;&#xC774;&#xB354;(service provider)&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; AppServiceProvider.php # &#xC6B0;&#xB9AC;&#xAC00; &#xB9CC;&#xB4E0; &#xC11C;&#xBE44;&#xC2A4;&#xB97C; &#xC11C;&#xBE44;&#xC2A4; &#xCEE8;&#xD14C;&#xC774;&#xB108;&#xC5D0; &#xB4F1;&#xB85D;&#xD558;&#xAE30; &#xC704;&#xD55C; &#xD074;&#xB798;&#xC2A4; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; AuthServiceProvider.php # &#xC0AC;&#xC6A9;&#xC790; &#xC778;&#xAC00;&#xC640; &#xAD00;&#xB828;&#xB41C; &#xC815;&#xCC45;&#xC744; &#xB4F1;&#xB85D;&#xD558;&#xAE30; &#xC704;&#xD55C; &#xD074;&#xB798;&#xC2A4; &#x2502; &#x2502; &#x251C;&#x2500;&#x2500; EventServiceProvider.php # &#xC774;&#xBCA4;&#xD2B8;&#xC640; &#xC774;&#xBCA4;&#xD2B8; &#xCC98;&#xB9AC;&#xAE30;&#xB97C; &#xC5F0;&#xACB0;&#xD558;&#xB294; &#xD074;&#xB798;&#xC2A4; &#x2502; &#x2502; &#x2514;&#x2500;&#x2500; RouteServiceProvider.php # routes.php &#xC5D0;&#xC11C; &#xC815;&#xC758;&#xD55C; &#xB77C;&#xC6B0;&#xD305;&#xC744; &#xD65C;&#xC131;&#xD654;&#xD558;&#xB294; &#xD074;&#xB798;&#xC2A4; &#x2502; &#x2514;&#x2500;&#x2500; User.php # &#xAE30;&#xBCF8; &#xB0B4;&#xC7A5; User &#xBAA8;&#xB378; &#x251C;&#x2500;&#x2500; composer.json # &#xC774; &#xD504;&#xB85C;&#xC81D;&#xD2B8;&#xC758; &#xC758;&#xC874;&#xC131; &#xB808;&#xC9C0;&#xC2A4;&#xD2B8;&#xB9AC; &#x251C;&#x2500;&#x2500; config # &#xB370;&#xC774;&#xD130;&#xBCA0;&#xC774;&#xC2A4;, &#xD050;, &#xBA54;&#xC77C; &#xB4F1; &#xC804;&#xC5ED; &#xC124;&#xC815;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x251C;&#x2500;&#x2500; database &#x2502; &#x251C;&#x2500;&#x2500; migrations # &#xC774; &#xD504;&#xB85C;&#xC81D;&#xD2B8;&#xC758; &#xB370;&#xC774;&#xD130;&#xBCA0;&#xC774;&#xC2A4; &#xD14C;&#xC774;&#xBE14; &#xC2A4;&#xD0A4;&#xB9C8;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2514;&#x2500;&#x2500; seeds # &#xB370;&#xC774;&#xD130;&#xBCA0;&#xC774;&#xC2A4; &#xD14C;&#xC774;&#xBE14;&#xC5D0; &#xB354;&#xBBF8; &#xB370;&#xC774;&#xD130;&#xB97C; &#xC0BD;&#xC785;&#xD558;&#xB294; &#xD074;&#xB798;&#xC2A4;&#xB4E4;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x251C;&#x2500;&#x2500; gulpfile.js # &#xC5D8;&#xB9AD;&#xC11C;(elixir, &#xD504;&#xB7F0;&#xD2B8; &#xC5D4;&#xB4DC; &#xBE4C;&#xB4DC; &#xC790;&#xB3D9;&#xD654;) &#xC2A4;&#xD06C;&#xB9BD;&#xD2B8; &#x251C;&#x2500;&#x2500; public # &#xC6F9; &#xC11C;&#xBC84; &#xB8E8;&#xD2B8;(document root) &#x251C;&#x2500;&#x2500; resources &#x2502; &#x251C;&#x2500;&#x2500; assets # &#xC5D8;&#xB9AD;&#xC11C; &#xBE4C;&#xB4DC; &#xC804;&#xC758; &#xC6D0;&#xBCF8; &#xC790;&#xBC14;&#xC2A4;&#xD06C;&#xB9BD;&#xD2B8;, CSS &#xB4F1;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x251C;&#x2500;&#x2500; lang # &#xB2E4;&#xAD6D;&#xC5B4; &#xC9C0;&#xC6D0;&#xC744; &#xC704;&#xD55C; &#xC5B8;&#xC5B4;&#xBCC4; &#xC0AC;&#xC804;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2502; &#x2514;&#x2500;&#x2500; views # &#xBDF0; &#xD30C;&#xC77C;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x251C;&#x2500;&#x2500; storage # &#xB77C;&#xB77C;&#xBCA8;&#xC758; &#xD30C;&#xC77C; &#xC800;&#xC7A5;&#xC18C; (&#xCE90;&#xC2DC;, &#xB85C;&#xADF8; &#xB4F1;) &#x251C;&#x2500;&#x2500; tests # &#xD14C;&#xC2A4;&#xD2B8; &#xD30C;&#xC77C;&#xC744; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; &#x2514;&#x2500;&#x2500; vendor # &#xC774; &#xD504;&#xB85C;&#xC81D;&#xD2B8;&#xAC00; &#xC758;&#xC874;&#xD558;&#xB294; &#xCEF4;&#xD3EC;&#xB10C;&#xD2B8;&#xB97C; &#xB2F4;&#xB294; &#xB514;&#xB809;&#xD130;&#xB9AC; 상위 디렉토리를 용도별로 다음과 같이 정리할 수 있습니다. app/ : 애플리케이션의 핵심 코드가 위치하는 곳. 모델, 컨트롤러, 서비스 프로바이더 등 이 폴더에 위치하게 된다. bootstrap : 라라벨 프레임워크 부팅에 필요한 파일과 속도 향상을 위해 컴파일된 php 파일이 위치하고 있다. (사용자는 이 디렉토리 안에 있는 파일들을 수정 할 필요가 없다고 한다.) config : 인증, DB, 세션, 메일, 큐 등 애플리케이션에 필요한 전역 설정을 담는 디렉토리. database : DB 스키마를 관리하는 migrations 와 초기 데이터를 설정하는 seeds 데이터, 모델에 데이터를 입력하기 위한 factories가 위치하는 디렉토리. public : 이미지, css, 글꼴, 자바스크립트 같은 정적 리소스와 라라벨의 인덱스 파일(index.php)이 위치한 곳. 웹 서버에 라라벨을 등록할 경우 DocumentRoot를 public으로 설정해야 정상 작동한다.(웹 서버 루트) resources : Less 같은 css 전처리기나 CoffeScript 같은 자바스크립트 프레임워크에서 사용하는 리소스와 뷰 코드, 다국어 지원 파일이 위치한 디렉토리. routes : 라우팅 정의 테이블이 있는 디렉토리. storage : 컴파일된 템플릿 파일, 캐시 데이터, 로그 파일 등이 위치. (라라벨의 파일 저장소) tests : PHPUnit으로 테스트를 작성할 경우 이 디렉토리에 위치. vendor : 의존성 있는 외부 라이브러리가 위치한 디렉토리. 라라벨 프로젝트는 [그림 1]과 같이 크게 4 부분으로 나눌 수 있습니다. 그림 1. 라라벨 프로젝트 구조 개발한 애플리케이션 layer laravel/laravel 라라벨 프레임 워크. 라라벨 핵심 컴포넌트(3) 와 외부 컴포넌트(4)를 조합하여 웹 서비스를 만들 수 있는 기본 틀 laravel/framework 라라벨 핵심 컴포넌트. 파운데이션 또는 커널이라 부르기도 한다. 외부 컴포넌트 라라벨 프로젝트를 생성할 때 보통 composer를 이용하여 composer create-project laravel/laravel blog --prefer-dist 와 같은 명령어를 사용하는데 이는 2번을 설치하는 것입니다. 새로 만든 composer.json 파일을 열어 보면 3번과 4번을 요구하는 내용이 선언된 것을 볼 수 있습니다. composer.json을 이용하여 설치를 수행하면 2,3,4에 해당하는 내용을 설치하게 됩니다. [그림 1]을 보시면 2번과 3번이 나누어져 있는 것을 볼 수 있습니다. 이는 라라벨 부 버전이 올라갈 때 큰 장점이 됩니다.라라벨 프레임워크(2)는 우리가 적성한 코드와 섞여져 있는 반면에 라라벨 핵심 컴포넌트(3)는 우리가 작성한 코드와 완전히 분리되어 있는데 이는 버전 변경의 충격을 흡수합니다. 즉 우리가 작성한 코드가 속한 완충 레이어(2)만 지침에 맞도록 업그레이드하면 됩니다. [참고 자료] https://appkr.github.io/l5book-snippets/draft/1001-installation.html https://laravel.kr/docs/5.3/structure https://www.lesstif.com/pages/viewpage.action?pageId=24445288","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"}]},{"title":"Laravel 작동 원리","date":"2017-11-04T15:00:00.000Z","path":"2017/11/05/laravel-logic/","text":"서버 이름을 foo.com 이라 가정 그림 1. Laravel logic client가 foo.com/posts 페이지를 http 요청하여 이를 웹 서버 가 받아 요청을 처리한다. 이때 client가 요청한 url을 분석하여 자신이 해결할 수 있는 파일(정적인 파일 css, image등)이면, 파일을 읽어서 곧바로 응답한다. 자신이 해결할 수 없는 파일이면 웹 서버 설정에 따라 PHP/라라벨에게 작업을 맡긴다. PHP에게 작업을 넘길 때는 index.php를 향하도록 URL 경로를 변경하여 넘기며(DocumentRoot 설정) index.php에 의해 라라벨의 부팅 시퀀스 가 실행된다. routes/web.php에 정의한 라우팅 테이블에서 posts을 찾는다. 만약 해당하는 라우트가 없으면 전역 예외 처리기 에 의해 웹 서버에게 오류 응답을 보낸다. 해당하는 라우트가 있으면 전역 미들웨어 와 posts 라우트에 정의한 라우트 미들웨어 가 http 요청을 필터링한다. 미들웨어 를 통과하지 못하면 예외가 발생하므로 전역 예외 처리기 를 통해 웹 서버에게 응답한다. 미들웨서 를 통과하면 posts 요청을 처리할 컨트롤러 에게 도달하게 된다. 컨트롤러 는 해당 요청을 처리하게 되는데 이때, 라라벨 컴포넌트 또는 외부 컴포넌트 등을 이용한다. 뿐만 아니라 요청을 처리하는 과정에 Database 와 통신을 하기도 하며 처리가 끝나면 http 응답을 만들고 반환하는데 응답 본문을 만들 때 템플릿 엔진 (ex. blade)을 이용하기도 한다. 웹 서버는 PHP/라라벨 측으로부터 넘겨받은 http 응답을 client에게 돌려준다. [참고 자료] https://appkr.github.io/l5book-snippets/draft/1001-installation.html","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"}]},{"title":"what is php-fpm","date":"2017-11-02T15:00:00.000Z","path":"2017/11/03/php-fpm/","text":"php-fpm 이란 ?보통 nginx + php-fpm 이런 조합을 많이 볼 수 있습니다. nginx는 apache 처럼 웹 서버 중 하나입니다. 그렇다면 php-fpm은 무엇일까요? nginx 웹서버(정적인 html 웹문서 파일을 웹브라우저에 전송해주는 역할)만으로는 동적인 페이지 구현이 어렵다 -&gt; 동적인 페이지 구현이 필요 -&gt; 웹서버 이외의 외부 프로그램에서 처리하는 방법을 사용 -&gt; 웹 서버에서 요청을 받아 그 요청을 외부 프로그램에 넘겨주면, 외부 프로그램은 프로그램 파일을 읽어 html로 변환하는 단계를 거친다. 이를 CGI라고 부른다. -&gt; php-fpm도 CGI에 해당(FastCGI) FastCGI vs CGICGI : 요청할때마다 새로운 프로세스 생성 FastCGI : 요청할때마다 새로운 프로세스를 생성하는 것이 아니라 이미 생성한 프로세스를 재활용하는 방법을 사용. 그래서 CGI보다 좀 더 빠른 버전이라고 할 수 있습니다. [참고 자료] https://www.conory.com/note_linux/42956","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"}]},{"title":"PHPStrom 단축키","date":"2017-11-02T15:00:00.000Z","path":"2017/11/03/phpstorm-shortcuts/","text":"Shift+Shift: 모든 것을 검색한다. Cmd+Shift+a: 액션과 옵션을 검색하여 실행한다. Cmd+Shift+o: 파일을 검색한다. Cmd+Shift+f: 프로젝트또는 지정 디렉토리에서 파일을 검색한다. Opt+up/Opt+down: 커서가 위치한 함수명, 함수전체 등으로 단계적으로 선택을 확장하거나 축소한다. Cmd+d: 커서가 위치한 줄을 복사한다. Opt+Shift+up: 커서가 위치한 줄을 하나 위로 옮긴다. down은 내린다. Cmd+Shift+up: 커서가 위치한 함수 전체를 위로 옮긴다. down은 내린다. Cmd+backspace: 커서가 위치한 줄 전체를 지운다. Cmd+Shift+backspace: 최근에 코딩한 위치로 돌아간다. Cmd + N (Ctrl + Enter): Generate (자동생성). Opt + Enter : import class, add method 등등 Ctrl + t : refetoring this Preference에 Live templates를 적극 활용하자 [참고 자료] https://nolboo.kim/blog/2016/06/14/phpstorm-shortcuts/ http://opennote46.tistory.com/58","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"phpstorm","slug":"phpstorm","permalink":"https://seunguklee.github.io/tags/phpstorm/"},{"name":"ide","slug":"ide","permalink":"https://seunguklee.github.io/tags/ide/"}]},{"title":"MVC Pattern","date":"2017-11-02T15:00:00.000Z","path":"2017/11/03/MVC-Pattern/","text":"MVC 패턴에 대해 알아보기 이전에 SoC(관심사의 분리)에 대해 우선 알아보겠습니다. 관심사의 분리(SoC) 란?관심사의 분리란 영어로 Separation of Concerns (SoC)라고 하며 각 부문이 각자의 관심사를 갖도록 컴퓨터 프로그램을 여러 부분으로 나누는 설계 원칙이라고 할 수 있습니다. 만약 할 일 목록을 출력하는 task.php 파일이 있습니다. 이 파일에는 다음과 같은 괌심사가 있다고 가정을 해봅니다. 어떤 DB를 사용할까? : MySQL? Oracle? DB 연결은 어떻게? mysql? mysqli? PDO? 만약 DB연결이 안되면? error message 출력? 다른 페이지로 이동? 할 일 데이터는 어떻게 가져올까? 절차지향? prepare 구문? 할 일 목록을 어떻게 표현할까? 이렇게 한꺼번에 많은 걱정을 해야 한다면 상당히 골치아픈 일입니다. 관심사의 분리(SoC)는 프로그램을 관심사 별로 쪼개어 가능하면 한 번에 한 가지 걱정만 함으로써 개발의 복잡성을 줄이며 유지보수 하기 좋은 코드로 만들자는 것입니다. 관심사의 분리의 장점관심사의 분리가 잘 이루어 지면 다음과 같은 장점이 있습니다. 개별 부문을 이해하기 쉽다. 각 부문을 재사용할 수 있게 된다. 한 부문을 수정할 때 다른 부문에 대해 자세히 알 필요가 없다. 다른 부문 변화에 신경 쓰지 않아도 된다. 관심사의 분리 기법으로 대표적으로 MVC 패턴이 있습니다. 이제 MVC 패턴에 대해 알아보겠습니다. MVC 패턴이란? MVC는 Model(M) View(V) Controller(C) 이렇게 3가지의 구성요소로 나누는 설계 패턴입니다. Model : Controller에 의해 호출되어 데이터소스에 데이터를 저장하거나, 데이터 소스에서 데이터를 가져와서 뷰가 사용할 수 있는 형태로 컨트롤러에 반환하는 역할 View : 컨트롤러에 의해 호출되어 클라이언트에게 응답으로 제공할 템플릿을 생성해서 컨트롤러에 반환 Controller : 사용자가 요청을 처리하고 응답을 되돌려주는 전체 과정을 관장합니다. 그림 1. MVC Pattern MVC 패턴은 일반적으로 다음 [그림 1]과 같은 순서로 client 요청을 처리하게 됩니다. 사용자의 요청을 컨트롤러가 받는다. 컨트롤러가 모델에게 데이터 처리를 요청 모델은 처리된 데이터를 컨트롤러에 반환 컨트롤러는 모델로부터 되돌려받은 데이터를 뷰에 전달 뷰는 응답을 생성하여 컨트롤러에 반환합니다. 컨트롤러가 브라우저에 뷰로 부터 되돌려받은 응답을 전송 MVC 패턴의 장점웹 애플리케이션을 개발할 때 MVC 패턴을 잘 적용하면 관심사의 분리(SoC)에 따른 장점을 얻게 됩니다. 개별 부문을 이해하기 쉽다. 가독성과 코드 재사용성 향상 다른 부문에 대해 신경 쓸 필요가 거의 없다. 유지보수와 협업이 쉬워진다. [참고 자료] https://medium.com/@smartbosslee/%EA%B4%80%EC%8B%AC%EC%82%AC%EC%9D%98-%EB%B6%84%EB%A6%AC-separation-of-concerns-soc-8a8d09df066d https://medium.com/@smartbosslee/php-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-mvc-%ED%8C%A8%ED%84%B4-1628b47b1b04","tags":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://seunguklee.github.io/tags/design-pattern/"}]},{"title":"Front Controller Pattern","date":"2017-11-02T15:00:00.000Z","path":"2017/11/03/Front-Controller-Pattern/","text":"웹 개발에 있어 대표적으로 권장하지 않는 방식이 있습니다. HTML(표현)과 PHP(비즈니스 로직)를 한 파일에 섞어 사용하는 방식 마치 HTML처럼 웹페이지별로 PHP 파일이 존재하고 이를 웹 브라우저로 접근하는 방식 1번과 같은 방식은 MVC 패턴을 이용하여 더 나은 방식으로 개선할 수 있습니다. 그렇다면 2번은 어떻게 하면 개선할 수 있을까요?2번과 같은 방식은 Front Controller 패턴을 이용하여 개선할 수 있습니다. (Front Controller는 라라벨에서 Router라고 생각하시면 됩니다.) Front Controller 패턴이란?Front Contrller 패턴은 웹 애플리케이션으로 오는 모든 사용자의 요청을 처리해주는 하나의 진입점을 두는 패턴입니다. 흔히 여러 웹 프레임워크에서 MVC 패턴과 함께 사용됩니다.(ex. Laravel Router) 그림 1. Front Controller Pattern Front Controller 패턴은 다음 [그림 1]과 같은 순서로 요청을 처리합니다. 사용자의 요청을 front controller가 받는다. front controller는 사용자의 요청을 분석하여 해당하는 컨트롤러에게 처리를 넘긴다. 컨트롤러가 모델에게 데이터 처리를 요청 모델은 처리된 데이터를 컨트롤러에 반환 컨트롤러는 모델로부터 되돌려받은 데이터를 뷰에 전달 뷰는 응답을 생성하여 컨트롤러에 반환합니다. 컨트롤러가 브라우저에 뷰로 부터 되돌려받은 응답을 전송 [참고 자료] https://medium.com/@smartbosslee/php-%EC%98%88%EC%A0%9C%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-%ED%94%84%EB%9F%B0%ED%8A%B8-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC-front-controller-%ED%8C%A8%ED%84%B4-c00e9d222963","tags":[{"name":"design-pattern","slug":"design-pattern","permalink":"https://seunguklee.github.io/tags/design-pattern/"}]},{"title":"컴포저","date":"2017-07-27T15:00:00.000Z","path":"2017/07/28/composer/","text":"라라벨를 처음 설치할 때 컴포저(composer)라는 놈을 설치해보았던 경험이 있을 것이다. 처음에는 이것이 무엇인지 모르고 그냥 설치하고 사용을 했을수도 있다. 이제 이 녀석 정체를 조금 알아보도록하자. 컴포저 란?컴포저는 PHP의 표준 의존성 관리 도구, PHP의 패키지 매니저라고 한다. 다른 프로그래밍 언어의 npm, bundle, pip, gradle, maven과 비슷한 것이라고 생각하면 될 것 같다. 그렇다면 의존성 관리 도구란 무엇일까? 다음과 같은 상황을 가정해보자. 컴포넌트 A를 가져왔는데 이 컴포넌트 A를 사용하려면 컴포넌트 B가 필요하고 컴포넌트 B를 사용하려면 컴포넌트 C가 필요하고… 결국엔 Z까지 필요한 상황이 발생했다. 그런데 새로운 컴포넌트는 기존에 사용하던 의존성과 충돌하는 하위 컴포넌트가 필요할 수도 있고, 자기들끼리 서로 필요한 상황도 발생 할 수도 있다. 이러한 상황을 ‘의존성 지옥’이라고 부르는데 의존성 관리 도구가 이러한 문제점의 해결을 돕는다. 컴포저 사용의 이점 다른 사람의 문제 해결 방법을 가져다 내 프로젝트에 쓸 수 있다. 검증된 품질 높은 컴포넌트 사용이 가능하다. install 및 update 등 컴포넌트 관리를 자동화 할 수 있다. Autoload 기능을 쉽게 사용 가능하다. 이는 require 지옥에서 벗어날 수 있다. 컴포터 컴포넌트(vendor)는 버전 관리에 포함되지 않아서 코드 공간이 줄어든다. 개발팀 및 테스트/운영 서버에서 개발 버전과 동일한 의존성을 사용하여 버전 불일치로 발생하는 문제점을 피할 수 있다.(composer.lock) composer.json 파일 살펴보기다음은 프로젝트의 composer.json 파일의 일부분을 가져 온 것이다. “require”: { “php”: “&gt;=5.6.4”, “laravel/framework”: “5.3.*”,}, &quot;require&quot; : 사용하고 있는 프로젝트가 의존하는 컴포넌트들의 목록들을 볼 수 있다. &quot;laravel/framework:&quot; &quot;5.3.*&quot; : laravel 은 벤더 이름이며, framework 는 패키지 이름이며 둘을 합쳐서 컴포넌트 이름 혹은 패키지라고 한다. 뒤에 5.3.* 은 가져올 버전을 말하며 5.3 버전 중 가장 최신을 가져온다는 뜻이다. “require-dev”: { “fzaninotto/faker”: “~1.4”, “mockery/mockery”: “0.9.“, “phpunit/phpunit”: “~5.0”, “symfony/css-selector”: “3.1.“, “symfony/dom-crawler”: “3.1.*”}, &quot;require-dev&quot; : 개발용으로만 필요한 컴포넌트 목록들을 볼 수 있다. “autoload”: { “classmap”: [ “database” ], “psr-4”: { “App\\“: “app/“ }}, &quot;autoload&quot; : 오토로딩, 개발을 할 때 하나의 파일에 많은 코드를 넣지 않고 일반적으로 여러 개의 파일을 나누어 코드를 구조화시켜 관리한다. 이런식으로 사용하다보면 다른 파일의 코드를 사용하기 위해 불러오는 경우가 발생하는데 PHP에서는 require를 이용한다. 하지만 불러올 파일이 많으면 require 키워드를 많이 사용해야되는 불편함이 발생할 수 있다. 오토로딩은 이러한 불편한 점을 해결해 준다. 참고로 라라벨은 PSR-4 오토로딩 표준을 이용한다하는데 PSR-4은 PHP-FIG에서 제시한 표준화된 클래스 오토로딩 방법이다. &quot;psr-4&quot; : App 네임스페이스의 루트를 app 디레토리라고 선언을 한 것이며 app 디레토리 아래의 파일들을 PSR-4 방식으로 불러온다고 컴포저에게 말하는 것이다. 그래서 app 디레토리 아래의 파일들을 열어 파일의 시작 부분을 보면 항상 namespace App\\... 로 시작하는 것을 볼 수 있다. &quot;classmap&quot; : database 디렉토리는 classmap 으로 읽어 들이고 있다. 그래서 database 아래의 클래스들은 namespace 선언이 없다. 즉 전역 네임스페이스를 이용한다는 의미이다. 정리하자면 \\App\\Post 를 코드에서 언급하게되면, 오토로더는 app/Post.php 파일에 필요한 클래스가 있다는 것을 스스로 인지하여 파일의 내용을 미리 읽어와서 준비해 두는 것이다. “scripts” : { .. } &quot;scripts&quot; : 프로젝트를 처음 만들었을 때, 컴포넌트를 설치하였을 때, 컴포넌트를 업데이트 하였을때 등 다양한 이벤트에서 실행할 콘솔 명령들을 정의한다. 컴포넌트들은 vendor 디레토리 아래에 설치되는데 우리가 정의한 컴포넌트보다 많은 것을 볼 수 있다. 이는 의존성의 의존성 때문이다.보통 팀 동료는 원격 코드 저장소로부터 vendor 디렉토리를 제외하고 받으며 $composer install 명령으로 필요한 컴포넌트들을 설치하는 것이 모범 사례이다. composer install, composer update $composer install : 프로젝트가 의존하는 컴포넌트를 처음 설치할 때 또는 composer.lock 에 정의된 컴포넌트 버전을 그대로 설치할 때 이 명령을 사용한다. $composer update : 이미 설치한 컴포넌트의 버전을 업그레이드할 때 이 명령을 사용한다. 버전 충돌 문제 해결방안 메뉴얼에서 제안하는 버전과 composer.json 파일의 충돌하는 컴포넌트 버전과 비교하여 일치하는지 확인한다. 아니라면 수정한다. composer.lock 파일 과 vendor 디렉토리를 삭제하고 $composer install 명령을 통하여 다시 컴포넌트를 설치 해본다. 다음 2가지 방법은 개발 중에만 사용할 수 있는 임시 방편이니 참고하도록 하자. 의존성을 require-dev로 옮기고 재시도 해보자. composer.json파일의 마지막 줄에 &quot;minimum-stability:&quot; &quot;dev&quot; 문장을 추가하여 재시도 해보자. ‘Could not fetch https://api.github.com/repos/… , please create a Github OAuth token to go over the API rate limit’ 와 같은 에러 메세지를 컴포저 실행 도중 만났다고 하자. 다음은 Github에서 PHP 컴포넌트를 가져올 때 시간당 요청 한도를 초과해서 발생한 문제인데 다음과 같이 해결 할 수 있다고 한다. 시간이 지난후 다시 시도 에러 메세지와 함께 표시된 Github URL을 방문하여 토근을 생성, 만든 토큰을 콘솔 프롬포트 Token (hidden): 에 붙여 넣는다. 오토로드컴포저는 vendor 디렉토리 아래에 자신이 참조할 데이터베이스를 미리 만들어 놓는데 이는 클래스 이름과 파일 경로 간 매핑을 담고 있으며 메모리에 올려 놓는 일을 vendor/autoload.php 파일이 한다. 오토로드는 어떤 클래스가 동작할 때 다른 클래스를 참조하면, 메모리에 적재된 컴포저 데이터베이스에서 매핑된 파일을 찾아 자동으로 require을 수행하는 식으로 작동한다. [참고 자료] https://appkr.github.io/l5book-snippets/draft/1017-composer.html","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"},{"name":"Composer","slug":"Composer","permalink":"https://seunguklee.github.io/tags/Composer/"}]},{"title":"what is node.js and express.js","date":"2017-07-26T15:00:00.000Z","path":"2017/07/27/what-is-nodejs-and-expressjs/","text":"Node.js란?Node.js는 WebServer가 아니다. 브라우저가 아닌 환경에서도 javascript를 사용할수 있게 하는 javascript runtime 이다. 서버 사이드에서도 많이 사용되며, 데스크탑 윈도우 프로그램으로 만들수도 있다. Apache경우에는 Html 파일경로를 지정해주고 서버를 열고 PHP를 실행한다던가 세션을 관리 등등 여러가지 일을 하지만 node.js 자체로는 아무것도 하지 않으며 그런 설정이 전혀 없다. 대신 Http 서버를 직접 작성해야한다. 즉, node.js는 코드를 실행할수 있는 하나의 방법에 불구한 javascript runtime이다. Express.js란?WebServer에서 필요한 대부분의 기능이 이미 구현된 Web Framework이다. 라우팅, 세션, 템플릿 등 Web Application을 만들때 필요한 많은 기능들이 이미 구현되어있다.","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"node.js","slug":"node-js","permalink":"https://seunguklee.github.io/tags/node-js/"},{"name":"express.js","slug":"express-js","permalink":"https://seunguklee.github.io/tags/express-js/"}]},{"title":"PHP의 객체지향 연산자","date":"2017-07-26T15:00:00.000Z","path":"2017/07/27/php-object-oriented-operators/","text":"-&gt; 연산자(object operator)PHP는 객체 컨텍스트에서 클래스 멤버에 접급할때 객체 연산자(-&gt;)를 사용한다. $user-&gt;address 이때 클래스 멤버란, 상수, 메서드, 프로퍼티 등을 통칭하여 클래스 멤버라고 한다.클래스 안에서 객체 자신을 참조할 때는 $this 키워드를 사용하며 객체 컨텍스트에서는 부모 클래스도 $this로 참조한다. $this-&gt;address :: 연산자(scope resolution operator)정적 클래스 멤버에 접근할때는 범위 확인 연산자(::)를 사용한다.1Str::random() 클래스 안에서 정적 멤버들과 결합해서 사용할 때는 self 키워드를 사용하여 자신을 표현한다.1self::random() 정적 프로퍼티에 접근할 때는 달러($) 기호를 붙여햐한다.1Class::$property 뿐만 아니라, 부모 클래스를 지칭할 때는 parent 키워드를 사용한다. 클래스와 메서드를 연결하여 문서에 표현할 때는 정적선언 여부와 상관없이 :: 연산자를 사용하는데 PHP 공식문서에도 이와 같은 표시 형식을 따르고 있으므로 PHP 문서를 볼 때 참고하면 될 것 같다.(1PDO::query() 참고로 App\\User::class 는 PHP5.6 이상부터 쓸 수 있는 문법이며 전체 클래스 경로를 반환한다.","tags":[{"name":"web","slug":"web","permalink":"https://seunguklee.github.io/tags/web/"},{"name":"php","slug":"php","permalink":"https://seunguklee.github.io/tags/php/"},{"name":"laravel","slug":"laravel","permalink":"https://seunguklee.github.io/tags/laravel/"}]}]